<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>US Maps - Enhanced Leaflet Viewer</title>
  
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
  
  <!-- Leaflet JS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
  
  <!-- Leaflet Heatmap Plugin -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-heat/0.2.0/leaflet-heat.min.js"></script>
  
  <!-- Leaflet MarkerCluster Plugin -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.1/MarkerCluster.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.1/MarkerCluster.Default.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.1/leaflet.markercluster.min.js"></script>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    html, body {
      width: 100%;
      height: 100%;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: #f5f5f5;
    }
    
    #map {
      width: 100%;
      height: 100%;
      z-index: 1;
    }
    
    /* SVG Pattern Definitions */
    svg defs {
      display: none;
    }
    
    /* Enhanced Leaflet zoom controls */
    .leaflet-control-zoom {
      border: 2px solid transparent !important;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3) !important;
      transition: all 0.3s ease !important;
    }
    
    .leaflet-control-zoom.focused {
      border: 3px solid #FFD700 !important;
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.9) !important;
      transform: scale(1.1);
    }
    
    .leaflet-control-zoom a {
      width: 40px !important;
      height: 40px !important;
      line-height: 40px !important;
      font-size: 24px !important;
      font-weight: bold !important;
      background-color: #007bff !important;
      color: white !important;
      transition: all 0.3s ease !important;
    }
    
    .leaflet-control-zoom a:hover {
      background-color: #0056b3 !important;
    }
    
    /* Enhanced popup styling */
    .leaflet-popup-content-wrapper {
      border-radius: 12px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
      padding: 4px;
    }
    
    .leaflet-popup-content {
      margin: 16px;
      font-size: 14px;
      line-height: 1.6;
    }
    
    /* Enhanced political layer styles */
    .political-boundary {
      fill: none;
      stroke: #4a6da7;
      stroke-width: 2px;
      stroke-linejoin: round;
      transition: all 0.3s ease;
      filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
    }
    
    .political-boundary:hover {
      stroke: #2c5282;
      stroke-width: 3px;
      filter: drop-shadow(0 4px 8px rgba(0,0,0,0.15));
    }
    
    .state-fill {
      fill: #ebf5ff;
      fill-opacity: 0.4;
      transition: all 0.3s ease;
    }
    
    .state-fill:hover {
      fill: #90cdf4;
      fill-opacity: 0.3;
    }
    
    .state-label {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 10px;
      font-weight: 500;
      letter-spacing: 0.2px;
      text-anchor: middle;
      fill: #374151;
      pointer-events: none;
      text-shadow:
        0 1px 1px rgba(255, 255, 255, 0.9),
        0 -1px 1px rgba(255, 255, 255, 0.9),
        1px 0 1px rgba(255, 255, 255, 0.9),
        -1px 0 1px rgba(255, 255, 255, 0.9);
      transition: all 0.2s ease;
    }
    
    /* Region label styles to match the reference design */
    .region-label {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 12px;
      font-weight: 500;
      color: #495057;
      text-align: center;
      white-space: nowrap;
      pointer-events: none;
      text-shadow: 
        0 1px 2px rgba(255, 255, 255, 0.8),
        0 -1px 2px rgba(255, 255, 255, 0.8),
        1px 0 2px rgba(255, 255, 255, 0.8),
        -1px 0 2px rgba(255, 255, 255, 0.8);
      transform: translate(-50%, -50%);
    }

    /* Layer-specific styles with patterns */
    .political-boundary {
      fill: url(#pattern-political) !important;
    }
    
    .choropleth-layer {
      fill: url(#pattern-choropleth) !important;
    }
    
    .county-boundary {
      fill: url(#pattern-county) !important;
    }
    
    .hydrology-layer {
      fill: url(#pattern-hydrology) !important;
    }
    
    .hazards-layer {
      fill: url(#pattern-hazards) !important;
    }
    
    .utilities-layer {
      fill: url(#pattern-utilities) !important;
    }
    
    /* Ensure patterns are visible on polygon fills */
    .leaflet-interactive {
      background-color: transparent !important;
    }
    
    /* Hover effect for regions */
    .region-boundary:hover {
      fill: #e9ecef !important;
      stroke: #adb5bd !important;
      stroke-width: 1.5px !important;
      transition: all 0.2s ease;
      filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
    }
    
    .political-boundary:hover {
      stroke: #2c5282;
      stroke-width: 3px;
      filter: drop-shadow(0 4px 8px rgba(0,0,0,0.15));
    }
    
    .state-fill {
      fill: #ebf5ff;
      fill-opacity: 0.4;
      transition: all 0.3s ease;
    }
    
    .popup-title {
      font-size: 18px;
      font-weight: bold;
      color: #1a1a1a;
      margin-bottom: 8px;
      padding-bottom: 8px;
      border-bottom: 2px solid #10b981;
    }
    
    .popup-value {
      font-size: 24px;
      font-weight: bold;
      color: #10b981;
      margin: 8px 0;
    }
    
    .popup-detail {
      color: #666;
      font-size: 13px;
      margin: 4px 0;
    }
    
    .popup-detail strong {
      color: #333;
    }
    
    /* Loading indicator */
    .loading {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255, 255, 255, 0.95);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      font-size: 1.2em;
      color: #1e40af;
      font-weight: 500;
      backdrop-filter: blur(4px);
      transition: opacity 0.5s ease-out;
    }
    
    .loading-spinner {
      width: 50px;
      height: 50px;
      border: 4px solid rgba(30, 64, 175, 0.1);
      border-radius: 50%;
      border-top-color: #1e40af;
      animation: spin 1s ease-in-out infinite;
      margin-bottom: 16px;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    .loading.active {
      display: block;
    }
    
    /* Enhanced legend */
    .legend {
      position: absolute;
      bottom: 20px;
      right: 20px;
      z-index: 1000;
      background: white;
      padding: 16px;
      border-radius: 12px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
      min-width: 200px;
      font-size: 13px;
    }
    
    .legend-title {
      font-weight: bold;
      font-size: 15px;
      margin-bottom: 12px;
      color: #1a1a1a;
      border-bottom: 2px solid #10b981;
      padding-bottom: 8px;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
    }
    
    .legend-color {
      width: 30px;
      height: 20px;
      border-radius: 4px;
      border: 1px solid rgba(0, 0, 0, 0.2);
      flex-shrink: 0;
    }
    
    .legend-label {
      color: #555;
      font-size: 12px;
    }
    
    /* Info panel */
    .info-panel {
      position: absolute;
      bottom: 20px;
      left: 20px;
      z-index: 1000;
      background: white;
      padding: 16px;
      border-radius: 12px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
      max-width: 320px;
      font-size: 13px;
      color: #333;
    }
    
    .info-title {
      font-weight: bold;
      font-size: 15px;
      margin-bottom: 8px;
      color: #1a1a1a;
    }
    
    .layer-status {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 10px;
    }
    
    .layer-badge {
      background: #e5e7eb;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 11px;
      color: #4b5563;
      font-weight: 500;
    }
    
    .layer-badge.active {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: white;
      box-shadow: 0 2px 4px rgba(16, 185, 129, 0.3);
    }
  </style>
</head>
<body>
  <!-- Add Inter font -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  
  <!-- SVG Pattern Definitions -->
  <svg width="0" height="0">
    <defs>
      <!-- Political: Diagonal Lines -->
      <pattern id="pattern-political" x="0" y="0" width="12" height="12" patternUnits="userSpaceOnUse">
        <line x1="0" y1="0" x2="12" y2="12" stroke="currentColor" stroke-width="2" opacity="0.6"/>
        <line x1="12" y1="0" x2="0" y2="12" stroke="currentColor" stroke-width="2" opacity="0.6"/>
      </pattern>
      
      <!-- County: Grid Pattern -->
      <pattern id="pattern-county" x="0" y="0" width="10" height="10" patternUnits="userSpaceOnUse">
        <rect x="0" y="0" width="10" height="10" fill="none" stroke="currentColor" stroke-width="1.5" opacity="0.5"/>
      </pattern>
      
      <!-- Choropleth: Dots -->
      <pattern id="pattern-choropleth" x="0" y="0" width="8" height="8" patternUnits="userSpaceOnUse">
        <circle cx="4" cy="4" r="2" fill="currentColor" opacity="0.6"/>
      </pattern>
      
      <!-- Hydrology: Waves -->
      <pattern id="pattern-hydrology" x="0" y="0" width="16" height="16" patternUnits="userSpaceOnUse">
        <path d="M0,8 Q4,4 8,8 T16,8" stroke="currentColor" stroke-width="1.5" fill="none" opacity="0.6"/>
      </pattern>
      
      <!-- Hazards: Crosses -->
      <pattern id="pattern-hazards" x="0" y="0" width="12" height="12" patternUnits="userSpaceOnUse">
        <line x1="6" y1="0" x2="6" y2="12" stroke="currentColor" stroke-width="1.5" opacity="0.6"/>
        <line x1="0" y1="6" x2="12" y2="6" stroke="currentColor" stroke-width="1.5" opacity="0.6"/>
      </pattern>
      
      <!-- Utilities: Small Dots -->
      <pattern id="pattern-utilities" x="0" y="0" width="6" height="6" patternUnits="userSpaceOnUse">
        <circle cx="3" cy="3" r="1.5" fill="currentColor" opacity="0.7"/>
      </pattern>
    </defs>
  </svg>
  
  <div id="map"></div>
  <div class="loading" id="loading">
    <div class="loading-spinner"></div>
    <span>Loading map data...</span>
  </div>
  
  <!-- Info Panel -->
  <div class="info-panel" id="infoPanel">
    <div class="info-title">ðŸ“Š Map Layers</div>
    <div class="layer-status" id="layerStatus"></div>
  </div>
  
  <!-- Legend (hidden by default) -->
  <div class="legend" id="legend" style="display: none;">
    <div class="legend-title" id="legendTitle">Legend</div>
    <div id="legendContent"></div>
  </div>

  <script>
    // ============================================================================
    // MAP INITIALIZATION
    // ============================================================================
    
    const map = L.map('map', {
      zoomControl: true,
      scrollWheelZoom: false,
      doubleClickZoom: false,
      touchZoom: false,
      boxZoom: false,
    }).setView([37.8, -96], 4);

    // Add clean base layer
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: 'Â© OpenStreetMap contributors',
    }).addTo(map);

    // ============================================================================
    // STATE MANAGEMENT
    // ============================================================================
    
    const layersRegistry = {};
    const layerStates = {};
    let activeLayers = new Set();
    let currentLegend = null;

    // ============================================================================
    // COLOR SCHEMES FOR CHOROPLETH
    // ============================================================================
    
    const COLOR_SCHEMES = {
      greens: ['#f7fcf5', '#e5f5e0', '#c7e9c0', '#a1d99b', '#74c476', '#41ab5d', '#238b45', '#006d2c', '#00441b'],
      blues: ['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#08519c', '#08306b'],
      reds: ['#fff5f0', '#fee0d2', '#fcbba1', '#fc9272', '#fb6a4a', '#ef3b2c', '#cb181d', '#a50f15', '#67000d'],
      purples: ['#fcfbfd', '#efedf5', '#dadaeb', '#bcbddc', '#9e9ac8', '#807dba', '#6a51a3', '#54278f', '#3f007d'],
      oranges: ['#fff5eb', '#fee6ce', '#fdd0a2', '#fdae6b', '#fd8d3c', '#f16913', '#d94801', '#a63603', '#7f2704'],
      teals: ['#f7fcfd', '#e5f5f9', '#ccece6', '#99d8c9', '#66c2a4', '#41ae76', '#238b45', '#006d2c', '#00441b'],
    };

    // ============================================================================
    // UTILITY FUNCTIONS
    // ============================================================================
    
    function setLoading(show) {
      const loadingEl = document.getElementById('loading');
      if (show) {
        loadingEl.classList.add('active');
      } else {
        loadingEl.classList.remove('active');
      }
    }

    function updateInfoPanel() {
      const statusEl = document.getElementById('layerStatus');
      if (activeLayers.size === 0) {
        statusEl.innerHTML = '<span class="layer-badge">No active layers</span>';
      } else {
        statusEl.innerHTML = Array.from(activeLayers)
          .map(id => `<span class="layer-badge active">${id.replace(/-/g, ' ')}</span>`)
          .join('');
      }
    }

    function sendMessage(type, data = {}) {
      if (window.ReactNativeWebView) {
        window.ReactNativeWebView.postMessage(JSON.stringify({ type, ...data }));
      }
      console.log('[Map Message]', type, data);
    }

    // ============================================================================
    // CHOROPLETH FUNCTIONS
    // ============================================================================
    
    /**
     * Get color for choropleth based on value
     */
    function getChoroplethColor(value, min, max, scheme = 'greens') {
      const colors = COLOR_SCHEMES[scheme] || COLOR_SCHEMES.greens;
      if (value === null || value === undefined) return colors[0];
      
      const normalized = (value - min) / (max - min);
      const index = Math.floor(normalized * (colors.length - 1));
      return colors[Math.max(0, Math.min(index, colors.length - 1))];
    }

    /**
     * Calculate min/max for dataset
     */
    function getMinMax(data, property) {
      let min = Infinity;
      let max = -Infinity;
      
      data.features.forEach(feature => {
        const value = feature.properties[property];
        if (value !== null && value !== undefined) {
          min = Math.min(min, value);
          max = Math.max(max, value);
        }
      });
      
      return { min, max };
    }

    /**
     * Create enhanced choropleth layer
     */
    function createChoroplethLayer(data, layerId, options = {}) {
      const {
        property = 'value',
        scheme = 'greens',
        unit = '',
        formatValue = (v) => v?.toLocaleString() || 'N/A'
      } = options;

      const { min, max } = getMinMax(data, property);
      
      console.log(`[Choropleth] ${layerId}: min=${min}, max=${max}, property=${property}`);

      const layer = L.geoJSON(data, {
        style: (feature) => {
          const value = feature.properties[property];
          const color = getChoroplethColor(value, min, max, scheme);
          
          return {
            fillColor: color,
            weight: 2,
            opacity: 1,
            color: '#ffffff',
            dashArray: '0',
            fillOpacity: 0.8,
          };
        },
        onEachFeature: (feature, layer) => {
          const props = feature.properties;
          const value = props[property];
          const name = props.NAME || props.name || props.STATE_NAME || 'Unknown';
          
          // Enhanced popup
          const popupContent = `
            <div class="popup-title">${name}</div>
            <div class="popup-value">${formatValue(value)}${unit}</div>
            ${Object.entries(props)
              .filter(([k, v]) => k !== property && k !== 'NAME' && k !== 'name')
              .slice(0, 3)
              .map(([k, v]) => `<div class="popup-detail"><strong>${k}:</strong> ${v}</div>`)
              .join('')}
          `;
          
          layer.bindPopup(popupContent, {
            className: 'enhanced-popup'
          });

          // Interactive effects
          layer.on({
            mouseover: (e) => {
              const layer = e.target;
              layer.setStyle({
                weight: 3,
                color: '#666',
                dashArray: '',
                fillOpacity: 0.9
              });
              layer.bringToFront();
            },
            mouseout: (e) => {
              const geoJsonLayer = layersRegistry[layerId];
              if (geoJsonLayer && geoJsonLayer.resetStyle) {
                geoJsonLayer.resetStyle(e.target);
              }
            },
            click: (e) => {
              map.fitBounds(e.target.getBounds());
            }
          });
        }
      });

      // Create legend
      createLegend(layerId, min, max, scheme, unit, formatValue);
      
      return layer;
    }

    /**
     * Create legend for choropleth
     */
    function createLegend(title, min, max, scheme, unit, formatValue) {
      const colors = COLOR_SCHEMES[scheme] || COLOR_SCHEMES.greens;
      const legendEl = document.getElementById('legend');
      const legendTitle = document.getElementById('legendTitle');
      const legendContent = document.getElementById('legendContent');
      
      legendTitle.textContent = title.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
      
      const step = (max - min) / (colors.length - 1);
      
      legendContent.innerHTML = colors.map((color, i) => {
        const value = min + (step * i);
        return `
          <div class="legend-item">
            <div class="legend-color" style="background: ${color}"></div>
            <div class="legend-label">${formatValue(value)}${unit}</div>
          </div>
        `;
      }).join('');
      
      legendEl.style.display = 'block';
      currentLegend = title;
    }

    /**
     * Hide legend
     */
    function hideLegend() {
      document.getElementById('legend').style.display = 'none';
      currentLegend = null;
    }

    // ============================================================================
    // ENHANCED GEOJSON LAYER
    // ============================================================================
    
    let selectedState = null;
    
    function createEnhancedGeoJSONLayer(data, layerId, color) {
      const layerType = {
        isPolitical: layerId.includes('political'),
        isChoropleth: layerId.includes('choropleth') || layerId.includes('demographics'),
        isHeatmap: layerId.includes('heatmap'),
        isCluster: layerId.includes('cluster'),
        isHydrology: layerId.includes('hydrology'),
        isHazards: layerId.includes('hazards'),
        isUtilities: layerId.includes('utilities'),
        isCounty: layerId.includes('county'),
        isRegion: layerId.includes('region')
      };
      
      // Calculate area-based coloring for polygon layers
      if ((layerType.isPolitical || layerType.isChoropleth || layerType.isCounty || layerType.isRegion) && data && data.features) {
        // First pass: calculate areas and find min/max for normalization
        const areas = data.features.map(feature => {
          const layer = L.geoJSON(feature);
          const coords = layer.getLayers()[0].getLatLngs();
          // Handle both simple and multi-polygon cases
          const area = Array.isArray(coords[0][0])
            ? coords[0].reduce((sum, latlngs) => sum + L.GeometryUtil.geodesicArea(latlngs), 0)
            : L.GeometryUtil.geodesicArea(coords[0]);
            
          return {
            id: feature.id,
            area: area,
            name: feature.properties.NAME || feature.properties.name || 'Unknown'
          };
        });
        
        // Sort areas for better distribution
        areas.sort((a, b) => a.area - b.area);
        
        // Find min and max areas for normalization
        const minArea = areas[0].area;
        const maxArea = areas[areas.length - 1].area;
        
        // Apply area-based coloring to all polygon layers
        // Larger areas get lighter colors, smaller areas get darker colors
        const areaData = new Map();
        
        // Define hue for each layer type
        const layerHues = {
          political: 210,    // Blue
          choropleth: 0,     // Red
          county: 120,       // Green
          region: 200,       // Light Blue
          hydrology: 200,    // Cyan
          hazards: 30        // Orange
        };
        
        // Determine which hue to use
        let hue = 210; // Default blue
        if (layerType.isPolitical) hue = layerHues.political;
        else if (layerType.isChoropleth) hue = layerHues.choropleth;
        else if (layerType.isCounty) hue = layerHues.county;
        else if (layerType.isRegion) hue = layerHues.region;
        else if (layerType.isHydrology) hue = layerHues.hydrology;
        else if (layerType.isHazards) hue = layerHues.hazards;
        
        areas.forEach(item => {
          // Normalize area to 0-1 range
          const normalizedArea = (item.area - minArea) / (maxArea - minArea);
          // Larger areas get lighter colors, smaller areas get darker colors
          const saturation = 100 - (normalizedArea * 50); // 100% to 50%
          const lightness = 30 + (normalizedArea * 50); // 30% to 80%
          const color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
          
          areaData.set(item.id, {
            area: item.area,
            color: color,
            opacity: 0.8,
            name: item.name
          });
        });
        
        // Add area-based color to each feature's properties
        data.features.forEach(feature => {
          if (areaData.has(feature.id)) {
            feature.properties._areaColor = areaData.get(feature.id).color;
            feature.properties._areaOpacity = areaData.get(feature.id).opacity;
          } else {
            const defaultColor = `hsl(${hue}, 100%, 30%)`;
            feature.properties._areaColor = defaultColor;
            feature.properties._areaOpacity = 0.8;
          }
        });
      }
      
      // Define base styles for different layer types with distinct patterns
      const layerStyles = {
        political: {
          className: 'political-boundary',
          fillColor: '#1d4ed8',
          color: '#1e3a8a',
          weight: 1.8,
          minOpacity: 0.3,
          maxOpacity: 0.9,
          patternId: 'pattern-political',
          markerType: 'circle',
          markerRadius: 6
        },
        choropleth: {
          className: 'choropleth-layer',
          fillColor: '#d62728',
          color: '#a50f15',
          weight: 1.5,
          minOpacity: 0.4,
          maxOpacity: 0.9,
          patternId: 'pattern-choropleth',
          markerType: 'square',
          markerRadius: 5
        },
        county: {
          className: 'county-boundary',
          fillColor: '#2ca02c',
          color: '#197019',
          weight: 1.2,
          minOpacity: 0.3,
          maxOpacity: 0.7,
          patternId: 'pattern-county',
          markerType: 'triangle',
          markerRadius: 5
        },
        region: {
          className: 'region-boundary',
          fillColor: '#f8f9fa',
          color: '#dee2e6',
          weight: 1.2,
          minOpacity: 0.9,
          maxOpacity: 0.95,
          labelColor: '#495057',
          labelWeight: '500',
          hoverColor: '#e9ecef',
          hoverBorder: '#adb5bd',
          pattern: 'none',
          markerType: 'rectangle',
          markerRadius: 4
        },
        hydrology: {
          className: 'hydrology-layer',
          fillColor: '#17becf',
          color: '#0e8a98',
          weight: 1.2,
          minOpacity: 0.3,
          maxOpacity: 0.8,
          patternId: 'pattern-hydrology',
          markerType: 'water-drop',
          markerRadius: 7
        },
        hazards: {
          className: 'hazards-layer',
          fillColor: '#ff7f0e',
          color: '#c45d0b',
          weight: 1.5,
          minOpacity: 0.2,
          maxOpacity: 0.9,
          patternId: 'pattern-hazards',
          markerType: 'warning',
          markerRadius: 8
        },
        utilities: {
          className: 'utilities-layer',
          fillColor: '#bcbd22',
          color: '#8a8b19',
          weight: 1.2,
          minOpacity: 0.2,
          maxOpacity: 0.8,
          patternId: 'pattern-utilities',
          markerType: 'cross',
          markerRadius: 6
        }
      };
      
      // Determine which style to use
      let styleKey = 'political';
      if (layerType.choropleth) styleKey = 'choropleth';
      else if (layerType.county) styleKey = 'county';
      else if (layerType.region) styleKey = 'region';
      else if (layerType.hydrology) styleKey = 'hydrology';
      else if (layerType.hazards) styleKey = 'hazards';
      else if (layerType.utilities) styleKey = 'utilities';
      
      const style = layerStyles[styleKey] || layerStyles.political;
      
      const layer = L.geoJSON(data, {
        pointToLayer: function(feature, latlng) {
          // Use distinct shapes for ALL point features based on layer type
          const radius = style.markerRadius || 6;
          const fill = feature.properties && feature.properties._areaColor ? feature.properties._areaColor : style.fillColor;
          
          switch(style.markerType) {
            case 'square':
              return L.divIcon({
                html: `<svg width="${radius*2}" height="${radius*2}" viewBox="0 0 24 24"><rect x="4" y="4" width="16" height="16" fill="${fill}" stroke="${style.color}"/></svg>`,
                className: 'custom-marker',
                iconSize: [radius*2, radius*2],
                iconAnchor: [radius, radius]
              });
            case 'triangle':
              return L.divIcon({
                html: `<svg width="${radius*2}" height="${radius*2}" viewBox="0 0 24 24"><path fill="${fill}" stroke="${style.color}" d="M12 2L2 22h20z"/></svg>`,
                className: 'custom-marker',
                iconSize: [radius*2, radius*2],
                iconAnchor: [radius, radius]
              });
            case 'water-drop':
              return L.divIcon({
                html: `<svg width="${radius*2}" height="${radius*2}" viewBox="0 0 24 24"><path fill="${fill}" stroke="${style.color}" d="M12 20c-3.31 0-6-2.69-6-6 0-4 6-10 6-10s6 6 6 10c0 3.31-2.69 6-6 6z"/></svg>`,
                className: 'custom-marker',
                iconSize: [radius*2, radius*2],
                iconAnchor: [radius, radius]
              });
            case 'warning':
              return L.divIcon({
                html: `<svg width="${radius*2}" height="${radius*2}" viewBox="0 0 24 24"><path fill="${fill}" stroke="${style.color}" d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/></svg>`,
                className: 'custom-marker',
                iconSize: [radius*2, radius*2],
                iconAnchor: [radius, radius]
              });
            case 'cross':
              return L.divIcon({
                html: `<svg width="${radius*2}" height="${radius*2}" viewBox="0 0 24 24"><path fill="${fill}" stroke="${style.color}" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>`,
                className: 'custom-marker',
                iconSize: [radius*2, radius*2],
                iconAnchor: [radius, radius]
              });
            case 'rectangle':
              return L.divIcon({
                html: `<svg width="${radius*2.5}" height="${radius*2}" viewBox="0 0 30 24"><rect x="4" y="6" width="22" height="12" fill="${fill}" stroke="${style.color}"/></svg>`,
                className: 'custom-marker',
                iconSize: [radius*2.5, radius*2],
                iconAnchor: [radius*1.25, radius]
              });
            case 'circle':
            default:
              return L.circleMarker(latlng, {
                radius: radius,
                fillColor: fill,
                color: style.color,
                weight: style.weight,
                opacity: 1,
                fillOpacity: style.maxOpacity
              });
          }
        },
        style: function(feature) {
          if (layerType.isPolitical || layerType.isChoropleth || layerType.isCounty || layerType.isRegion || layerType.isHydrology || layerType.isHazards) {
            const baseOpacity = feature.properties._areaOpacity || 0.3;
            const adjustedOpacity = Math.max(style.minOpacity, Math.min(style.maxOpacity, baseOpacity));
            
            // Use area-based color for all polygon layers
            let fillColor = style.fillColor;
            if (feature.properties._areaColor) {
              fillColor = feature.properties._areaColor;
            }
            
            // Apply SVG pattern fill for visual distinction
            let fillPattern = fillColor;
            if (style.patternId) {
              fillPattern = `url(#${style.patternId})`;
            }
            
            const styleObj = {
              className: style.className,
              weight: style.weight,
              opacity: 1,
              fill: true,
              fillColor: fillPattern,
              fillOpacity: adjustedOpacity,
              color: style.color,
              dashArray: '',
              lineJoin: 'round',
              transition: 'all 0.3s ease'
            };
            
            return styleObj;
          }
          
          // Special styling for region layer to match the reference design
          if (layerType.isRegion) {
            const label = feature.properties.NAME || feature.properties.name || feature.properties.REGION || '';
            const center = layer.getBounds().getCenter();
            
            // Add state/region label
            if (label && layer.getBounds().getNorthEast().distanceTo(layer.getBounds().getSouthWest()) > 10000) {
              L.marker(center, {
                icon: L.divIcon({
                  className: 'region-label',
                  html: label,
                  iconSize: null,
                  iconAnchor: [0, 0]
                }),
                interactive: false
              }).addTo(layer);
            }
            
            // Style for the region
            return {
              className: style.className,
              weight: style.weight,
              color: style.color,
              opacity: 0.9,
              fill: true,
              fillColor: style.fillColor,
              fillOpacity: style.maxOpacity,
              dashArray: '',
              lineJoin: 'round',
              interactive: true
            };
          }
          
          // For other layer types (hydrology, hazards, etc.)
          if (layerType.isHydrology || layerType.isHazards) {
            return {
              className: style.className,
              weight: style.weight,
              color: style.color,
              opacity: 0.8,
              fill: true,
              fillColor: style.fillColor,
              fillOpacity: style.maxOpacity - 0.1,
              dashArray: layerType.isHydrology ? '5, 5' : '',
              lineJoin: 'round'
            };
          }
          return {
            color: color || '#1f77b4',
            weight: 2,
            opacity: 1,
            fill: true,
            fillColor: color || '#1f77b4',
            fillOpacity: 0.3,
          };
        },
        onEachFeature: function(feature, layer) {
          if (isPolitical && feature.properties) {
            // Add state name as a label
            if (feature.properties.NAME || feature.properties.name) {
              const name = feature.properties.NAME || feature.properties.name;
              const center = layer.getBounds().getCenter();
              
              // Only add label if it's not too small to be visible
              if (layer.getBounds().getNorthEast().distanceTo(layer.getBounds().getSouthWest()) > 1000) {
                L.marker(center, {
                  icon: L.divIcon({
                    className: 'state-label',
                    html: name,
                    iconSize: null,
                    iconAnchor: [0, 0]
                  }),
                  interactive: false
                }).addTo(layer);
              }
            }
          }
          
          if (feature.properties) {
            const popupContent = document.createElement('div');
            popupContent.className = 'popup-content';
            
            const title = document.createElement('h3');
            title.className = 'popup-title';
            title.textContent = feature.properties.NAME || feature.properties.name || 'Feature';
            popupContent.appendChild(title);
            
            const details = document.createElement('div');
            details.className = 'popup-details';
            
            // Add state-specific details
            if (isPolitical) {
              const stateInfo = document.createElement('div');
              stateInfo.className = 'popup-value';
              
              if (feature.properties.STATE_ABBR) {
                stateInfo.textContent = feature.properties.STATE_ABBR;
              } else if (feature.properties.STATE_NAME) {
                stateInfo.textContent = feature.properties.STATE_NAME;
              }
              
              popupContent.appendChild(stateInfo);
            }
            
            // Add other properties
            const propsList = document.createElement('div');
            Object.entries(feature.properties).forEach(([key, value]) => {
              if (['name', 'NAME', 'STATE_ABBR', 'STATE_NAME'].includes(key)) return;
              
              const propItem = document.createElement('p');
              propItem.innerHTML = `<strong>${key}:</strong> ${value}`;
              propsList.appendChild(propItem);
            });
            
            details.appendChild(propsList);
            popupContent.appendChild(details);
            
            layer.bindPopup(popupContent);

            // Add a centroid shape marker for polygon features to emphasize distinct shapes per layer
            try {
              if (feature.geometry && (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon')) {
                const center = layer.getBounds().getCenter();
                const radius = style.markerRadius || 6;
                const fill = feature.properties && feature.properties._areaColor ? feature.properties._areaColor : style.fillColor;
                let icon;
                switch (style.markerType) {
                  case 'square':
                    icon = L.divIcon({
                      html: `<svg width="${radius*2}" height="${radius*2}" viewBox="0 0 24 24"><rect x="4" y="4" width="16" height="16" fill="${fill}" stroke="${style.color}"/></svg>`,
                      className: 'custom-centroid',
                      iconSize: [radius*2, radius*2],
                      iconAnchor: [radius, radius]
                    });
                    break;
                  case 'triangle':
                    icon = L.divIcon({
                      html: `<svg width="${radius*2}" height="${radius*2}" viewBox="0 0 24 24"><path fill="${fill}" stroke="${style.color}" d="M12 2L2 22h20z"/></svg>`,
                      className: 'custom-centroid',
                      iconSize: [radius*2, radius*2],
                      iconAnchor: [radius, radius]
                    });
                    break;
                  case 'water-drop':
                    icon = L.divIcon({
                      html: `<svg width="${radius*2}" height="${radius*2}" viewBox="0 0 24 24"><path fill="${fill}" stroke="${style.color}" d="M12 20c-3.31 0-6-2.69-6-6 0-4 6-10 6-10s6 6 6 10c0 3.31-2.69 6-6 6z"/></svg>`,
                      className: 'custom-centroid',
                      iconSize: [radius*2, radius*2],
                      iconAnchor: [radius, radius]
                    });
                    break;
                  case 'warning':
                    icon = L.divIcon({
                      html: `<svg width="${radius*2}" height="${radius*2}" viewBox="0 0 24 24"><path fill="${fill}" stroke="${style.color}" d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/></svg>`,
                      className: 'custom-centroid',
                      iconSize: [radius*2, radius*2],
                      iconAnchor: [radius, radius]
                    });
                    break;
                  case 'cross':
                    icon = L.divIcon({
                      html: `<svg width="${radius*2}" height="${radius*2}" viewBox="0 0 24 24"><path fill="${fill}" stroke="${style.color}" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>`,
                      className: 'custom-centroid',
                      iconSize: [radius*2, radius*2],
                      iconAnchor: [radius, radius]
                    });
                    break;
                  case 'rectangle':
                    icon = L.divIcon({
                      html: `<svg width="${radius*2.5}" height="${radius*2}" viewBox="0 0 30 24"><rect x="4" y="6" width="22" height="12" fill="${fill}" stroke="${style.color}"/></svg>`,
                      className: 'custom-centroid',
                      iconSize: [radius*2.5, radius*2],
                      iconAnchor: [radius*1.25, radius]
                    });
                    break;
                  case 'circle':
                  default:
                    icon = L.divIcon({
                      html: `<svg width="${radius*2}" height="${radius*2}" viewBox="0 0 24 24"><circle cx="12" cy="12" r="8" fill="${fill}" stroke="${style.color}"/></svg>`,
                      className: 'custom-centroid',
                      iconSize: [radius*2, radius*2],
                      iconAnchor: [radius, radius]
                    });
                }
                L.marker(center, { icon, interactive: false }).addTo(map);
              }
            } catch (e) {
              console.warn('Centroid marker error:', e);
            }
            
            // Store original style to revert back
            const baseOpacity = isPolitical ? (feature.properties._areaOpacity || 0.3) : 0.7;
            const originalStyle = {
              weight: isPolitical ? 1.5 : 1.5,
              color: isPolitical ? '#1e40af' : (color || '#4b5563'),
              fillOpacity: baseOpacity,
              fill: isPolitical ? '#3b82f6' : (color || '#f3f4f6'),
              transition: 'all 0.3s ease'
            };
            
            // Add hover effects for non-region layers
            if (!layerType.isRegion) {
              layer.on('mouseover', function() {
                this.setStyle({
                  weight: 2.5,
                  color: style.hoverBorder || '#1e3a8a',
                  fillOpacity: Math.min(0.9, baseOpacity + 0.3),
                  fill: style.hoverColor || '#2563eb',
                  dashArray: ''
                });
                this.bringToFront();
              });

              layer.on('mouseout', function() {
                layer.setStyle(originalStyle);
              });
            }
            
            // Add click interaction
            layer.on('click', function(e) {
              // Reset previously selected state
              if (selectedState) {
                selectedState.setStyle(originalStyle);
                selectedState.getElement().classList.remove('state-selected');
              }
              
              // Set new selected state
              selectedState = layer;
              layer.setStyle({
                weight: 2,
                color: '#1d4ed8',
                fill: '#dbeafe',
                fillOpacity: 0.7,
                dashArray: ''
              });
              
              // Add selected class
              const element = layer.getElement();
              if (element) {
                element.classList.add('state-selected');
              }
              
              // Bring to front and open popup
              layer.bringToFront();
              layer.openPopup();
            });
            
            // Enhanced hover effects
            layer.on('mouseover', function() {
              if (layer !== selectedState) {
                layer.setStyle({
                  weight: 1.5,
                  color: '#1d4ed8',
                  fill: '#e5e7eb',
                  fillOpacity: 0.8,
                  dashArray: ''
                });
              }
              layer.bringToFront();
              document.body.style.cursor = 'pointer';
            });
            
            layer.on('mouseout', function() {
              if (layer !== selectedState) {
                layer.setStyle(originalStyle);
              }
              document.body.style.cursor = '';
            });
            
            // Add touch support for mobile
            layer.on('touchstart', function() {
              if (layer !== selectedState) {
                layer.fire('click');
              }
            });
          }
        },
        pointToLayer: function(feature, latlng) {
          return L.circleMarker(latlng, {
            radius: 8,
            fillColor: color || '#3b82f6',
            color: '#fff',
            weight: 2,
            opacity: 0.9,
            fillOpacity: 0.8,
            className: 'point-marker',
          });
        }
      });
      
      return layer;
    }

    // ============================================================================
    // ENHANCED HEATMAP
    // ============================================================================
    
    function createEnhancedHeatmap(data) {
      const points = [];
      
      if (data.features) {
        data.features.forEach((feature) => {
          if (feature.geometry && feature.geometry.coordinates) {
            const coords = feature.geometry.coordinates;
            let intensity = 0.5;
            
            if (feature.properties) {
              intensity = feature.properties.magnitude ||
                         feature.properties.intensity ||
                         feature.properties.value ||
                         0.5;
              
              if (intensity > 1) {
                intensity = Math.min(intensity / 10000000, 1);
              }
            }
            
            points.push([coords[1], coords[0], intensity]);
          }
        });
      }

      if (points.length === 0) return null;

      return L.heatLayer(points, {
        radius: 30,
        blur: 20,
        maxZoom: 17,
        max: 1.0,
        gradient: {
          0.0: '#0000ff',
          0.2: '#00ffff',
          0.4: '#00ff00',
          0.6: '#ffff00',
          0.8: '#ff7f00',
          1.0: '#ff0000',
        },
      });
    }

    // ============================================================================
    // ENHANCED CLUSTER
    // ============================================================================
    
    function createEnhancedCluster(data) {
      const markers = L.markerClusterGroup({
        maxClusterRadius: 80,
        disableClusteringAtZoom: 17,
        spiderfyOnMaxZoom: true,
        showCoverageOnHover: false,
        zoomToBoundsOnClick: true,
      });

      if (data.features) {
        data.features.forEach((feature) => {
          if (feature.geometry && feature.geometry.type === 'Point') {
            const coords = feature.geometry.coordinates;
            const marker = L.marker([coords[1], coords[0]]);
            
            if (feature.properties) {
              const props = Object.entries(feature.properties)
                .slice(0, 5)
                .map(([k, v]) => `<div class="popup-detail"><strong>${k}:</strong> ${v}</div>`)
                .join('');
              marker.bindPopup(`<div>${props}</div>`);
            }
            
            markers.addLayer(marker);
          }
        });
      }

      return markers.getLayers().length > 0 ? markers : null;
    }

    // ============================================================================
    // LAYER LOADING
    // ============================================================================
    
    async function fetchGeoJSON(url) {
      try {
        const separator = url.includes('?') ? '&' : '?';
        const finalUrl = url.includes('f=geojson') ? url : `${url}${separator}f=geojson`;
        
        console.log('[Fetch] Loading:', finalUrl);
        const response = await fetch(finalUrl);
        
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        return await response.json();
      } catch (error) {
        console.error('[Fetch] Error:', error);
        return null;
      }
    }

    function getLayerColor(layerId) {
      const colors = {
        'street-base': '#1f77b4',
        'satellite': '#ff7f0e',
        'political-boundaries': '#ff7f0e',
        'county-map': '#2ca02c',
        'state-boundaries': '#059669',
        'choropleth': '#d62728',
        'heatmap': '#9467bd',
        'cluster-map': '#8c564b',
        'hydrology': '#17becf',
        'utilities': '#bcbd22',
        'hazards': '#ff9896',
        'demographics': '#98df8a',
      };
      return colors[layerId] || '#1f77b4';
    }

    async function loadLayer(layerId, url, layerType = 'geojson', options = {}) {
      if (layersRegistry[layerId]) {
        console.log(`[Load] Layer ${layerId} already loaded`);
        return true;
      }

      setLoading(true);

      try {
        let layer = null;

        if (layerType === 'tile') {
          layer = L.tileLayer(url, {
            maxZoom: 19,
            attribution: 'Esri',
          });
        } else {
          const data = await fetchGeoJSON(url);
          if (!data) throw new Error('Failed to fetch GeoJSON');

          // Determine layer type
          if (layerId.includes('choropleth') || layerType === 'choropleth') {
            layer = createChoroplethLayer(data, layerId, {
              property: options.property || 'POP2007',
              scheme: options.scheme || 'greens',
              unit: options.unit || '',
              formatValue: options.formatValue
            });
          } else if (layerId.includes('heatmap')) {
            layer = createEnhancedHeatmap(data);
          } else if (layerId.includes('cluster')) {
            layer = createEnhancedCluster(data);
          } else {
            const color = getLayerColor(layerId);
            layer = createEnhancedGeoJSONLayer(data, layerId, color);
          }
        }

        if (layer) {
          layersRegistry[layerId] = layer;
          layerStates[layerId] = { loaded: true, visible: false };
          console.log(`[Load] âœ… Layer ${layerId} loaded successfully`);
          sendMessage('layerLoaded', { layerId, success: true });
          return true;
        } else {
          throw new Error('Failed to create layer');
        }
      } catch (error) {
        console.error(`[Load] âŒ Error loading ${layerId}:`, error);
        sendMessage('layerLoaded', { layerId, success: false, message: error.message });
        return false;
      } finally {
        setLoading(false);
      }
    }

    function toggleLayer(layerId) {
      const layer = layersRegistry[layerId];
      if (!layer) {
        console.error(`[Toggle] Layer ${layerId} not found`);
        return false;
      }

      const state = layerStates[layerId];
      
      if (state.visible) {
        map.removeLayer(layer);
        state.visible = false;
        activeLayers.delete(layerId);
        
        if (currentLegend === layerId) {
          hideLegend();
        }
      } else {
        layer.addTo(map);
        state.visible = true;
        activeLayers.add(layerId);
      }

      updateInfoPanel();
      sendMessage('layerToggled', { layerId, visible: state.visible });
      return state.visible;
    }

    function clearAllLayers() {
      activeLayers.forEach((layerId) => {
        const layer = layersRegistry[layerId];
        if (layer && layerStates[layerId].visible) {
          map.removeLayer(layer);
          layerStates[layerId].visible = false;
        }
      });
      activeLayers.clear();
      hideLegend();
      updateInfoPanel();
    }

    // ============================================================================
    // DIRECTIONS / ROUTES HANDLING
    // ============================================================================
    
    let currentRoute = null;
    let routePolyline = null;
    let routeMarkers = [];

    function clearRoute() {
      if (routePolyline) {
        map.removeLayer(routePolyline);
        routePolyline = null;
      }
      
      routeMarkers.forEach((marker) => {
        map.removeLayer(marker);
      });
      routeMarkers = [];
      
      currentRoute = null;
    }

    function showRoute(routeData) {
      // Clear existing route
      clearRoute();
      
      if (!routeData.coordinates || routeData.coordinates.length === 0) {
        console.warn('No coordinates provided for route');
        return;
      }

      currentRoute = routeData;

      // Create polyline for the route with blue color (Google Maps style)
      routePolyline = L.polyline(routeData.coordinates, {
        color: '#0066ff',
        weight: 5,
        opacity: 0.85,
        lineCap: 'round',
        lineJoin: 'round',
        dashArray: '0',
        className: 'route-polyline',
      }).addTo(map);

      // Add start marker (green)
      if (routeData.coordinates.length > 0) {
        const startCoord = routeData.coordinates[0];
        const startMarker = L.circleMarker([startCoord[0], startCoord[1]], {
          radius: 10,
          fillColor: '#00cc00',
          color: '#fff',
          weight: 3,
          opacity: 1,
          fillOpacity: 0.95,
          className: 'route-start-marker',
        })
          .bindPopup('<strong>Start</strong>', { closeButton: false })
          .addTo(map);
        routeMarkers.push(startMarker);
      }

      // Add intermediate waypoint markers (blue)
      if (routeData.coordinates.length > 2) {
        for (let i = 1; i < routeData.coordinates.length - 1; i++) {
          const coord = routeData.coordinates[i];
          const waypointMarker = L.circleMarker([coord[0], coord[1]], {
            radius: 7,
            fillColor: '#0066ff',
            color: '#fff',
            weight: 2,
            opacity: 1,
            fillOpacity: 0.85,
            className: 'route-waypoint-marker',
          })
            .bindPopup('<strong>Waypoint ' + i + '</strong>', { closeButton: false })
            .addTo(map);
          routeMarkers.push(waypointMarker);
        }
      }

      // Add end marker (red)
      if (routeData.coordinates.length > 0) {
        const endCoord = routeData.coordinates[routeData.coordinates.length - 1];
        const endMarker = L.circleMarker([endCoord[0], endCoord[1]], {
          radius: 10,
          fillColor: '#ff3333',
          color: '#fff',
          weight: 3,
          opacity: 1,
          fillOpacity: 0.95,
          className: 'route-end-marker',
        })
          .bindPopup('<strong>End</strong>', { closeButton: false })
          .addTo(map);
        routeMarkers.push(endMarker);
      }

      // Fit map bounds to route with padding
      const bounds = L.latLngBounds(routeData.coordinates);
      map.fitBounds(bounds, { padding: [80, 80], maxZoom: 9 });

      console.log('âœ… Route displayed:', routeData.name || 'Unknown');
      console.log('ðŸ“ Markers added:', routeMarkers.length, '| Coordinates:', routeData.coordinates.length);
      sendMessage('routeDisplayed', { routeId: routeData.id, success: true });
    }

    // ============================================================================
    // MESSAGE HANDLING
    // ============================================================================
    
    window.handleMapMessage = function(message) {
      try {
        const data = JSON.parse(message);
        console.log('[Message]', data);

        switch (data.type) {
          case 'loadLayer':
            loadLayer(data.layerId, data.url, data.layerType, data.options);
            break;
          case 'toggleLayer':
            if (!layerStates[data.layerId]?.loaded) {
              loadLayer(data.layerId, data.url, data.layerType, data.options)
                .then(() => toggleLayer(data.layerId));
            } else {
              toggleLayer(data.layerId);
            }
            break;
          case 'clearLayers':
            clearAllLayers();
            break;
          case 'showRoute':
            showRoute(data);
            break;
          case 'clearRoute':
            clearRoute();
            break;
          default:
            console.warn('[Message] Unknown type:', data.type);
        }
      } catch (error) {
        console.error('[Message] Error:', error);
      }
    };

    // Zoom control functions
    window.focusZoomControl = function(focus) {
      const zoomControl = document.querySelector('.leaflet-control-zoom');
      if (zoomControl) {
        if (focus) {
          zoomControl.classList.add('focused');
        } else {
          zoomControl.classList.remove('focused');
        }
      }
    };

    window.clickZoomIn = function() {
      document.querySelector('.leaflet-control-zoom-in')?.click();
    };

    window.clickZoomOut = function() {
      document.querySelector('.leaflet-control-zoom-out')?.click();
    };

    // Expose API
    window.mapAPI = {
      loadLayer,
      toggleLayer,
      clearAllLayers,
      getActiveLayers: () => Array.from(activeLayers),
      getLayerRegistry: () => layersRegistry,
    };

    console.log('âœ… Enhanced map initialized');
    updateInfoPanel();
    sendMessage('mapReady', { success: true });
  </script>
</body>
</html>